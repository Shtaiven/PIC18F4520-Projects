;;;;;;; GamePIC for QwikFlash board ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Small game console for PIC18F including the games PIC Shooter and PIC Racer
;
;;;;;;; Program hierarchy ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; ...
;
;;;;;;; Assembler directives ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        list  P=PIC18F4520, F=INHX32, C=160, N=0, ST=OFF, MM=OFF, R=DEC, X=ON
        #include <P18F4520.inc>
        __CONFIG  _CONFIG1H, _OSC_HS_1H  ;HS oscillator
        __CONFIG  _CONFIG2L, _PWRT_ON_2L & _BOREN_ON_2L & _BORV_2_2L  ;Reset
        __CONFIG  _CONFIG2H, _WDT_OFF_2H  ;Watchdog timer disabled
        __CONFIG  _CONFIG3H, _CCP2MX_PORTC_3H  ;CCP2 to RC1 (rather than to RB3)
        __CONFIG  _CONFIG4L, _LVP_OFF_4L & _XINST_OFF_4L  ;RB5 enabled for I/O
        errorlevel -314, -315          ;Ignore lfsr messages

;;;;;;; Variables ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        cblock  0x000                  ;Beginning of Access RAM
		OLDPORTD					   ;Holds previous value of RPG inputs
		TEMP						   ;Temporary local variable
		DELRPG						   ;Generated by RPG
        TMR0LCOPY                      ;Copy of sixteen-bit Timer0 used by LoopTime
        TMR0HCOPY
        INTCONCOPY                     ;Copy of INTCON for LoopTime subroutine
		COUNT
        VCOUNT                         ;Counter for Vsync
		ENEMCOUNT					   ;Counter to track how many seconds pass
		ENEMSPAWN					   ;Counter for enemy spawn delay
		ENEMTEMP
        BYTE                           ;Eight-bit byte to be displayed
        BYTESTR:10                     ;Display string for binary version of BYTE
		SHIPPOS:3					   ;Stores ship position and sprite for PIC shooter
		ENEMPOS:10					   ;Store enemy positions and states
		RANDTEMP					   ;Temporarily store random number
		SCORE
        endc

;;;;;;; Macro definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MOVLF   macro  literal,dest
        movlw  literal
        movwf  dest
        endm

POINT   macro  stringname
        MOVLF  high stringname, TBLPTRH
        MOVLF  low stringname, TBLPTRL
        endm

DISPF	macro  register
        movff  register,BYTE		
        call  ByteDisplay
        endm

RAND	macro  literal			;must be a power of 2-1 from 2^0-1 to 2^7-1
		movf  TMR0L,W
		andlw  literal
		endm

INC0	macro
		movff  INDF0,POSTINC0
		endm

DEC0	macro
		movff  INDF0,POSTDEC0
		endm

;;;;;;; Vectors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        org  0x0000                    ;Reset vector
        nop 
        goto  Mainline

        org  0x0008                    ;High priority interrupt vector
        goto  $                        ;Trap

        org  0x0018                    ;Low priority interrupt vector
        goto  $  

;;;;;;; Mainline program ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Mainline
        rcall  Initial                 ;Initialize everything
		POINT  ShootSprite			   ;Load sprite sheet
		rcall  DisplayC
		POINT  PIC1
		rcall  DisplayC
		POINT  Shooter2
		rcall  DisplayC

		MOVLF  200,COUNT			   ; wait 2 seconds
StartScreen
		rcall  LoopTime
		decf  COUNT,F
		bnz	StartScreen

Restart
		rcall  GameInit

L1
		; Main game loop
		rcall DrawShip	
		rcall DrawEnemy
		rcall Vsync
        bra	L1

;;;;;;; Initial subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine performs all initializations of variables and registers.

Initial
        MOVLF  B'10001110',ADCON1      ;Enable PORTA & PORTE digital I/O pins
        MOVLF  B'11100001',TRISA       ;Set I/O for PORTA
        MOVLF  B'11011100',TRISB       ;Set I/O for PORTB
        MOVLF  B'11010000',TRISC       ;Set I/0 for PORTC
        MOVLF  B'00001111',TRISD       ;Set I/O for PORTD
        MOVLF  B'00000100',TRISE       ;Set I/O for PORTE
        MOVLF  B'10001000',T0CON       ;Set up Timer0 for a looptime of 10 ms
        MOVLF  B'00010000',PORTA       ;Turn off all four LEDs driven from PORTA
		movff  PORTD,OLDPORTD		   ;Initialize "old" value
        rcall  InitLCD
        return

;;;;;;; GameInit subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine performs all initializations for the game.

GameInit		
		MOVLF  50,ENEMCOUNT
		MOVLF  3,ENEMSPAWN
		clrf  SCORE

		MOVLF  0x80,ENEMPOS			   ;Init ENEMPOS for enemy display
		MOVLF  0x20,ENEMPOS+1
		MOVLF  0x20,ENEMPOS+2
		MOVLF  0x20,ENEMPOS+3
		MOVLF  0x20,ENEMPOS+4
		MOVLF  0x20,ENEMPOS+5
		MOVLF  0x20,ENEMPOS+6
		MOVLF  0x20,ENEMPOS+7
		MOVLF  0x20,ENEMPOS+8
		clrf  ENEMPOS+9

		MOVLF  0xc4,SHIPPOS		   	   ;Init SHIPPOS for ship display
		MOVLF  0x0b,SHIPPOS+1
		clrf  SHIPPOS+2

		POINT Clear1			   	   ;Clear LCD to spaces
		rcall DisplayC
		POINT Clear2			  	
		rcall DisplayC

		lfsr  0,ENEMPOS				   ; Display initial enemy position
		rcall  DisplayV
		return

;;;;;;; InitLCD subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Initialize the Optrex 8x2 character LCD.
; First wait for 0.1 second, to get past display's power-on reset time.

InitLCD
        MOVLF  10,COUNT                ;Wait 0.1 second
        ;REPEAT_
L2
          rcall  LoopTime              ;Call LoopTime 10 times
          decf  COUNT,F
        ;UNTIL_  .Z.
        bnz	L2
RL2

        bcf  PORTE,0                   ;RS=0 for command
        POINT  LCDstr                  ;Set up table pointer to initialization string
        tblrd*                         ;Get first byte from string into TABLAT
        ;REPEAT_
L3
          bsf  PORTE,1                 ;Drive E high
          movff  TABLAT,PORTD          ;Send upper nibble
          bcf  PORTE,1                 ;Drive E low so LCD will process input
          rcall  LoopTime              ;Wait ten milliseconds
          bsf  PORTE,1                 ;Drive E high
          swapf  TABLAT,W              ;Swap nibbles
          movwf  PORTD                 ;Send lower nibble
          bcf  PORTE,1                 ;Drive E low so LCD will process input
          rcall  LoopTime              ;Wait ten milliseconds
          tblrd+*                      ;Increment pointer and get next byte
          movf  TABLAT,F               ;Is it zero?
        ;UNTIL_  .Z.
        bnz	L3
RL3
        return

;;;;;;; RPG subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine decyphers RPG changes into values of DELRPG of 0, +1, or -1.
; DELRPG = +1 for CW change, 0 for no change, and -1 for CCW change.
; SASM.EXE is required to compile this properly (http://www.microdesignsinc.com/picbook/downloads.html)

RPG
		clrf  DELRPG			;Clear for "no change" return value
		movf  PORTD,W			;Copy PORTD into W
		movwf  TEMP				; and TEMP
		xorwf  OLDPORTD,W		;Anychange?
		andlw  B'00000011'		;If not, set Z flag
;		IF_  .NZ.				;If the two bits have changed then...
		btfsc  	STATUS,Z
		bra ENDIF_1
		  rrcf OLDPORTD,W		;Form what a CCW change would produce
;		  IF_  .C.				;Make new bit 1 = compliment of old bit 0
		  btfss  STATUS,C
		  bra  ELSE_2
			bcf  WREG,1
		  bra  ENDIF_2
;		  ELSE_
		  ELSE_2
			bsf  WREG,1
;		  ENDIF_
		  ENDIF_2
		  xorwf  TEMP,W			;Did the RPG actually change to this output?
		  andlw  B'00000011'
;		  IF_  .Z.				;If so, then change DELRPG to -1 for CCW
		  btfss  STATUS,Z
		  bra  ELSE_3
		    decf  DELRPG,F
		  bra  ENDIF_3
;		  ELSE_					;Otherwise, change DELRPG to +1 for CW
		  ELSE_3
		    incf  DELRPG,F
;		  ENDIF_
		  ENDIF_3
;		ENDIF_
		ENDIF_1
		movff  TEMP,OLDPORTD	;Save PORTD as OLDPORTD for ten ms from now
		return

;;;;;;; T40 subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Pause for 40 microseconds  or 40/0.4 = 100 clock cycles.
; Assumes 10/4 = 2.5 MHz internal clock rate.

T40
        movlw  100/3                   ;Each REPEAT loop takes 3 cycles
        movwf  COUNT
        ;REPEAT_
L4
          decf  COUNT,F
        ;UNTIL_  .Z.
        bnz	L4
RL4
        return

;;;;;;;;DisplayC subroutine;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine is called with TBLPTR containing the address of a constant
; display string.  It sends the bytes of the string to the LCD.  The first
; byte sets the cursor position.  The remaining bytes are displayed, beginning
; at that position.
; This subroutine expects a normal one-byte cursor-positioning code, 0xhh, or
; an occasionally used two-byte cursor-positioning code of the form 0x00hh.

DisplayC
        bcf  PORTE,0                   ;Drive RS pin low for cursor-positioning code
        tblrd*                         ;Get byte from string into TABLAT
        movf  TABLAT,F                 ;Check for leading zero byte
        ;IF_  .Z.
        bnz	L5
          tblrd+*                      ;If zero, get next byte
        ;ENDIF_
L5
        ;REPEAT_
L6
          bsf  PORTE,1                 ;Drive E pin high
          movff  TABLAT,PORTD          ;Send upper nibble
          bcf  PORTE,1                 ;Drive E pin low so LCD will accept nibble
          bsf  PORTE,1                 ;Drive E pin high again
          swapf  TABLAT,W              ;Swap nibbles
          movwf  PORTD                 ;Write lower nibble
          bcf  PORTE,1                 ;Drive E pin low so LCD will process byte
          rcall  T40                   ;Wait 40 usec
          bsf  PORTE,0                 ;Drive RS pin high for displayable characters
          tblrd+*                      ;Increment pointer, then get next byte
          movf  TABLAT,F               ;Is it zero?
        ;UNTIL_  .Z.
        bnz	L6
RL6
        return

;;;;;;; DisplayV subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine is called with FSR0 containing the address of a variable
; display string.  It sends the bytes of the string to the LCD.  The first
; byte sets the cursor position.  The remaining bytes are displayed, beginning
; at that position.

DisplayV
        bcf  PORTE,0                   ;Drive RS pin low for cursor positioning code
        ;REPEAT_
L7
          bsf  PORTE,1                 ;Drive E pin high
          movff  INDF0,PORTD           ;Send upper nibble
          bcf  PORTE,1                 ;Drive E pin low so LCD will accept nibble
          bsf  PORTE,1                 ;Drive E pin high again
          swapf  INDF0,W               ;Swap nibbles
          movwf  PORTD                 ;Write lower nibble
          bcf  PORTE,1                 ;Drive E pin low so LCD will process byte
          rcall  T40                   ;Wait 40 usec
          bsf  PORTE,0                 ;Drive RS pin high for displayable characters
          movf  PREINC0,W              ;Increment pointer, then get next byte
        ;UNTIL_  .Z.                   ;Is it zero?
        bnz	L7
RL7
        return

;;;;;;; LoopTime subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This subroutine waits for Timer0 to complete its ten millisecond count
; sequence. It does so by waiting for sixteen-bit Timer0 to roll over. To obtain
; a period of precisely 10000/0.4 = 25000 clock periods, it needs to remove
; 65536-25000 or 40536 counts from the sixteen-bit count sequence.  The
; algorithm below first copies Timer0 to RAM, adds "Bignum" to the copy ,and
; then writes the result back to Timer0. It actually needs to add somewhat more
; counts to Timer0 than 40536.  The extra number of 12+2 counts added into
; "Bignum" makes the precise correction.

Bignum  equ     65536-25000+12+2

LoopTime
        ;REPEAT_
L9
        ;UNTIL_  INTCON,TMR0IF == 1    ;Wait until ten milliseconds are up
        btfss INTCON,TMR0IF
        bra	L9
RL9
        movff  INTCON,INTCONCOPY       ;Disable all interrupts to CPU
        bcf  INTCON,GIEH
        movff  TMR0L,TMR0LCOPY         ;Read 16-bit counter at this moment
        movff  TMR0H,TMR0HCOPY
        movlw  low  Bignum
        addwf  TMR0LCOPY,F
        movlw  high  Bignum
        addwfc  TMR0HCOPY,F
        movff  TMR0HCOPY,TMR0H
        movff  TMR0LCOPY,TMR0L         ;Write 16-bit counter at this moment
        movf  INTCONCOPY,W             ;Restore GIEH interrupt enable bit
        andlw  B'10000000'
        iorwf  INTCON,F
        bcf  INTCON,TMR0IF             ;Clear Timer0 flag
        return

Vsync	
		MOVLF 2,VCOUNT
Vsync_L1		
		rcall  LoopTime
		decf  VCOUNT
		bnz  Vsync_L1
		return

;;;;;;; ByteDisplay subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Display whatever is in BYTE as a binary number.

ByteDisplay
        lfsr  0,BYTESTR+8
        ;REPEAT_
L10
          clrf  WREG
          rrcf  BYTE,F                 ;Move bit into carry
          rlcf  WREG,F                 ;and from there into WREG
          iorlw  0x30                  ;Convert to ASCII
          movwf  POSTDEC0              ; and move to string
          movf  FSR0L,W                ;Done?
          sublw  low BYTESTR
        ;UNTIL_  .Z.
        bnz	L10
RL10

        lfsr  0,BYTESTR                ;Set pointer to display string
        MOVLF  0xc0,BYTESTR            ;Add cursor-positioning code
        clrf  BYTESTR+9                ;and end-of-string terminator
        rcall  DisplayV
		return

;;;;;;; DrawShip subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Update ship location for PIC shooter.

DrawShip
		POINT Clear2
		rcall DisplayC
		rcall  RPG
		movf  DELRPG,W
		addwf  SHIPPOS,F
		movlw  B'00000111'
		andwf  SHIPPOS,F			; # stored in SHIPPOS (from RPG)
		movlw  B'11000000'		
		iorwf  SHIPPOS,F		; location of ship stored in SHIPPOS in format 0xc#
		lfsr  0,SHIPPOS				; point to SHIPPOS
		btfss  PORTD,RD3			; is button being pressed?
		bra  ELSE_DrawShip_1
			MOVLF  0x0b,SHIPPOS+1	; if pressed, draw shooting ship
			bra  ENDIF_DrawShip_1
		ELSE_DrawShip_1
			MOVLF  0x0c,SHIPPOS+1	; if not pressed, draw regular ship	
		ENDIF_DrawShip_1
		clrf  SHIPPOS+2
		rcall DisplayV			; draw ship
		return

;;;;;;; DrawEnemy subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Update enemy locations for PIC shooter.

DrawEnemy		
		decfsz  ENEMCOUNT,F				; IF ENEMCOUNT = 0 (every 1s)
		bra  ENDIF_DrawEnemy_3		
			MOVLF  50,ENEMCOUNT			; reset ENEMCOUNT
			decf  ENEMSPAWN
			lfsr  0,ENEMPOS+8
EnemLoop_1								; LOOP through each enemy location
			movf  INDF0,W
			sublw  0x20					; IF enemy exists...
			bz  ENDIF_DrawEnemy_1	
				movf  INDF0,W			; IF enemy would move past final position, go to game over
				sublw  0x0a
				bnz  ELSE_DrawEnemy_1
					rcall  GameOver
					;bra  ENDIF_DrawEnemy_1 ;DEBUG
				ELSE_DrawEnemy_1
					incf INDF0,F		; ELSE increment enemy position
			ENDIF_DrawEnemy_1
			DEC0						; decrement pointer
			movf  FSR0L,W				; Did we reach the end of the display?
			sublw  low ENEMPOS
			bnz  EnemLoop_1				; If not, keep looping
REnemLoop_1			
		tstfsz  ENEMSPAWN
		bra  ENDIF_DrawEnemy_3			; IF ENEMSPAWN = 0 (every 3s)		
			MOVLF  3,ENEMSPAWN			; reset ENEMSPAWN
			lfsr  0,ENEMPOS+1			; point to first enemy position in array (ENEMPOS)
			RAND 7						; generate random number between 0 and 7
			movwf  RANDTEMP
			bz  REnemLoop_2
EnemLoop_2			
			INC0						; increment FSR0 n times (n is the random number)
			decf  RANDTEMP,F
			bnz  EnemLoop_2
REnemLoop_2
			; IF enemy already exists in that location, don't draw it	
			movf  INDF0,W				; move dereferenced pointer value into WREG (ASCII code at that position)
			sublw  0x20					; subtract space character from WREG (0x20)
			bnz  ENDIF_DrawEnemy_3		; branch if not 0 to ENDIF_DrawEnemy_3
			; ELSE draw enemy
				MOVLF  0x08, INDF0		; draw first enemy character (0x08) at pointer location
			;ENDIF
		ENDIF_DrawEnemy_3
		; IF button is pressed, destroy enemy
		btfsc  PORTD,RD3				; Check if button is pressed
		bra  END_DrawEnemy				; skip to END_DrawEnemy if not pressed
			movf  SHIPPOS,W			    ; find position of ship
			andlw  B'00001111'			; convert to corresponding enemy position
			movwf  TEMP
			movf  TEMP,F				; check zero flag
			lfsr  0,ENEMPOS+1			; point to first enemy position in array (ENEMPOS)
			bz  REnemLoop_3				; increment to corresponding enemy position...
EnemLoop_3			
			INC0						; increment FSR0
			decf  TEMP,F
			bnz  EnemLoop_3
REnemLoop_3
			movf  INDF0,W				; If there's an enemy there...
			sublw  0x20
			bz  END_DrawEnemy
				MOVLF  0x20,INDF0			; replace enemy with space character (0x20)
				incf  SCORE,F				; increase score
END_DrawEnemy
		lfsr  0,ENEMPOS
		rcall  DisplayV
		return


;;;;;;; GameOver subroutine ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Ship explosion animation and game over screen which displays the score.

GameOver
		MOVLF  3,TEMP
	
		lfsr  0,SHIPPOS+1			; point to the ship sprite
		MOVLF  0x0d,INDF0			; replace with first explosion sprite
		
Explosion_Loop
		lfsr  0,SHIPPOS				
		rcall  DisplayV				; Display it
		MOVLF  25,COUNT				;   for 1/4 second
GameOver_1
		rcall  LoopTime
		decf  COUNT,F
		bnz	GameOver_1

		lfsr  0,SHIPPOS+1			; go to next frame of explosion
		incf  INDF0,F
		decf  TEMP,F
		bnz  Explosion_Loop
				
		POINT  GameOver1		; display "GAME OVER"
		rcall DisplayC
		POINT  GameOver2
		rcall DisplayC

		MOVLF  100,COUNT		; wait 1 second
GameOver_2
		rcall  LoopTime
		decf  COUNT,F
		bnz	GameOver_2

ScoreScreen
		POINT  Score1
		rcall  DisplayC
		DISPF  SCORE
		btfsc  PORTD,RD3
		bra  ScoreScreen
		bra  Restart
		return

;;;;;;; Sprite Definitions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Sprite definitions for each game

LCDstr  db  0x33,0x32,0x28,0x01,0x0c,0x06,0x00  ;Initialization string for LCD

ShootSprite			; PIC Shooter sprites
		db	0x00, 0x40  										; CGRAM Positioning code
		db	0x84, 0x8e, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80		; Enemy position 1
		db	0x80, 0x80, 0x80, 0x84, 0x8e, 0x80, 0x80, 0x80		; Enemy position 2
		db	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x84, 0x8e		; Enemy position 3
		db	0x80, 0x80, 0x80, 0x84, 0x84, 0x8e, 0x9f, 0x8a		; Ship (Player)
		db	0x80, 0x84, 0x80, 0x84, 0x84, 0x8e, 0x9f, 0x8a		; Ship shooting
		db	0x80, 0x80, 0x80, 0x80, 0x84, 0x8e, 0x84, 0x80		; Explosion frame 1
		db	0x80, 0x80, 0x80, 0x84, 0x8a, 0x95, 0x8a, 0x84		; Explosion frame 2
		db	0x80, 0x84, 0x8a, 0x91, 0x80, 0x84, 0x80, 0x91		; Explosion frame 3
		db  0x00												; Null string terminator

Ship	db	0x0b		; Ship sprite start
Enemy	db	0x08		; Enemy sprite start
Boom	db	0x0d		; Explosion sprite start

RaceSprite			; PIC Racer sprites
		db	0x00, 0x40											; CGRAM Positioning code
		db	0x80, 0x94, 0x9e, 0x9a, 0x9a, 0x9e, 0x94, 0x80		; Car (Player)
		db	0x80, 0x83, 0x85, 0x87, 0x87, 0x87, 0x83, 0x80		; Obstacle start
		db	0x80, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x80		; Obstacle middle
		db	0x80, 0x98, 0x9c, 0x9c, 0x9c, 0x9c, 0x98, 0x80		; Obstacle end
		db	0x94, 0x9e, 0x9a, 0x88, 0x80, 0x9a, 0x9e, 0x94		; Crash frame 1
		db	0x9e, 0x9a, 0x80, 0x88, 0x80, 0x84, 0x9a, 0x9e		; Crash frame 2
		db	0x9e, 0x80, 0x82, 0x88, 0x80, 0x84, 0x80, 0x9a		; Crash frame 3
		db	0x80, 0x80, 0x82, 0x88, 0x80, 0x84, 0x80, 0x80		; Crash frame 4
		db  0x00												; Null string terminator

Car		db	0x08		; Car sprite
Block	db	0x09		; Obstacle sprite start
Crash	db	0x0c		; Crash sprite start

SpriteTest1			; Test spriteset on top row
		db	0x80, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00

SpriteTest2			; Test spriteset on bottom row
		db	0xc0, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00

Clear1
		db  "\x80        \x00"
Clear2
		db  "\xc0        \x00"

GameOver1  db  "\x80  GAME  \x00"
GameOver2  db  "\xc0  OVER  \x00"
Score1  db  "\x80SCORE:\x00"

PIC1  db  "\x80PIC\x00
Shooter2  db  "\xc0Shooter\x00

end

